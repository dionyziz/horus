\section{A Password Wallet}

Let us start by building a password-based wallet without the use of private keys.
This construction will be a stepping stone for the next. In this construction, we
will have a severe limitation: The wallet can only be used to spend \emph{once},
and at a \emph{predetermined time}. Once the wallet has been used, it cannot be
reused with the same password. Furthermore, the wallet becomes unusuable if the
funds have not been spent prior to the maturity date.

From a user point of view, the wallet works as follows. Initially, Alice chooses
a secret password with $\lambda$ bits of entropy. We will determine this $\lambda$
later, but let us say, with foresight, that it will be enough to have a password
just $6$ alphanumeric characters long. Alice also chooses a \emph{maturity date},
a timestamp in the future (expressed as chain height),
and uses her wallet software to generate
a smart contract which she then posts on the chain. This generates a public wallet
address for Alice that she can use to receive multiple payments prior to the maturiy date.
The wallet software can then
be discarded and no secret information needs to be kept by Alice, beyond the
secret password that she remembers, and the public contract that remains on the chain.
No private keys are stored anywhere.
A short period before the maturity date arrives,
Alice uses the wallet software to connect to the chain network, and enters her
password and desired destination. The software issues two transactions to the chain:
First, a $\textsf{tx}_\textsf{commit}$ transaction, which lets Alice illustrate prior
knowledge of her secret password; and, second, a $\textsf{tx}_\textsf{reveal}$ transaction,
in which Alice proves that her previous commitment indeed corresponds to the secret
password committed on the chain. The first transaction is posted strictly prior to the maturity
date, while the second transaction is posted on or after the maturity date.

Let us explore how the contract is implemented.
The smart contract construction for the wallet is illustrated in
Algorithm~\ref{alg.password}. It consists of three methods: A \textsf{construct}
method, called when the wallet is initialized; a \textsf{commit} method, called
shortly prior to the maturity date; and a \textsf{reveal} method, called after
the maturity date. These two last methods are used for spending.

When Alice wishes to deploy her wallet, she
begins by generating a password $sk \gets \{0, 1\}^\lambda$. She also chooses
a future timestamp at which she will be able to spend her money.
She submits this information to her
software wallet.
The software wallet connects to
the blockchain and observes the current stable blockchain tip $B = \chain[-k]$
and its height $t_0$.
Alice's timestamp choice is translated to a future block height $\Delta \in \mathbb{N}$ which
denotes how far in the future,
in block height after $t_0$, she wants to spend her money: If $\Delta = 100$, the money will
be spendable when the blockchain reaches height $t_0 + \Delta$ blocks.
We set $t_1 = t_0 + \Delta$ to be the block height at which spending becomes possible.
The software wallet constructs the contract of Algorithm~\ref{alg.password}
by broadcasting its construction transaction $\textsf{tx}_\textsf{construct}$
to the blockchain network.
The constructor accepts two parameters: The $t_1$ parameter,
and the $c$ parameter. The $c$ parameter is a timelock-encrypted
ciphertext of her password. Concretely, Alice's software wallet
sets $c = \textsf{timelock}(sk, t)$ by invoking $\textsf{WE.Enc}_\mathcal{R}(sk, x)$.
Here, $\mathcal{R}$ denotes the polynomially computable relation validating block headers
starting from a particular block and continuing up to a prespecified block height, checking
ancestry and proof-of-work nonces, as described in the preliminaries. The problem instance $x = (B, t)$
is the tuple consisting of the latest known stable block and the maturity height.
Observe now that the ciphertext $c$ which is published on the
smart contract and known to the adversary is a ciphertext which can only be decrypted
after $t$ blocks have been mined on top of block $B$. The transaction returns a wallet address $pk$
at which she can receive money prior to the maturity height.

\import{./}{algorithms/alg.password.tex}

To spend her money, Alice runs the wallet software anew and inputs her public wallet address $pk$,
her password $sk$, and destination address $\textsf{to}$. The wallet software does not have any information beyond this.
The software runs an honest chain node which observes a chain $\chain$.
At any time before its local chain reaches height $t_1 - \ell - 2k$,
the wallet generates a new high-entropy salt $\textsf{salt} \gets \{0, 1\}^\kappa$ (where $\kappa$
is a security parameter in the order of $128$). This salt
is short-lived ($\ell - 2k$ blocks) and must survive until the chain reaches height $t_1$.
It then creates a transaction $\textsf{tx}_\textsf{commit}$.
This transaction contains
a commitment $z$ evaluated as $z = H(\left<sk, \textsf{salt}, \textsf{to}\right>)$,
where we assume that the encoding $\left<\cdot\right>$ denotes a uniquely decodable encoding
of the triplet.
This transaction is submitted to the smart contract by invoking the \textsf{commit} method.
Due to the liveness of the ledger, the transaction is confirmed in a block with
height at most $t_1 - 2k$. The smart contract records the commitment, as the requirement
in Line~\ref{alg.password.delay} is satisfied, and stores it in the \textsf{commitments} set.

After the local chain of the wallet reaches height $t_1$ (due to the Chain Growth lower bound, this
will be soon enough~\cite{backbone}), the software gathers the block headers
$\chain[t_0{:}t_1]$ to construct a timelock witness $w$. It then creates a transaction
$\textsf{tx}_\textsf{reveal}$ which invokes the \textsf{reveal} method of the smart contract
and includes the plaintext password $sk$, which now becomes publicly reveal, the plaintext
$\textsf{salt}$, which also becomes public information, the target address $\textsf{to}$, and
the witness $w$. The \textsf{reveal} method checks that the submitted data corresponds to the
previous commitment, and that the stores encrypted password $c$ timelock decrypts to the provided
password $sk$. In that case, it forwards the money to the $\textsf{to}$ address.

We now give a high-level analysis of the correctness and security of this scheme.
The \emph{correctness} property of the wallet mandates that the honest wallet user can
create a valid spending transaction, i.e., a transaction which executes
$\textsf{reveal}$ to completion. The \emph{security} property mandates that the adversary
cannot create a valid transaction. These properties, together, ensure that the honest user
can spend her money, while the adversary cannot.

\begin{theorem}[Correctness (Informal)]
  Let the blockchain have \emph{liveness} and \emph{safety},
  and let the witness encryption scheme $\textsf{WE}$ be \emph{correct}.
  Then Algorithm~\ref{alg.password} is \emph{correct}.
\end{theorem}
\begin{proof}[Sketch]
  The contract is created when $B = \chain[-k]$ is stable. Due to safety, all the future chains
  will be extending this block. The contract is initialized with $x = (B, t)$ by issuing the
  $\textsf{tx}_\textsf{construct}$ transaction. Due to liveness, this transaction is confirmed
  within $\ell$ blocks.
  The honest user then creates a transaction $\textsf{tx}_\textsf{commit}$ when her
  own chain has length $|\chain| = t_1 - \ell - 2k$.
  Due to liveness, this transaction becomes confirmed for all honest parties after $\ell$ blocks
  have elapsed, and is placed in position $\chain[t_1 - 2k]$ or earlier. Therefore, Line~\ref{alg.password.delay}
  of the method \textsf{commit} succeeds. When $|\chain| = t_1$, the honest user calls
  \textsf{reveal}, passing $w$. Due to the correctness of the witness encryption scheme,
  the decryption succeeds. The password and salt revealed match the ones committed.
  Due to liveness, this transaction becomes confirmed.
\end{proof}

Our security analysis is in a hybrid \emph{cryptographic} and \emph{cryptoeconomic}
setting.
In the system described, we have two security parameters. First, we have
the \emph{cryptographic} security
parameter $\kappa$ ($\approx 128$ bits), which determines the security of the hash function,
the security of the witness encryption scheme, and the security of the blockchain (in terms
of liveness, safety, and common prefix). The probability of failure is negligible in this
parameter. Any breakage in this parameter can be catastrophic for the system and
can potentially provide the adversary with gains without any cost.
Secondly, we have the much shorter \emph{cryptoeconomic} security parameter $\lambda$
($\approx 35$ bits) which denotes the entropy of the chosen user password.
While this parameter is hopelessly short from a cryptographic
point of view (and $2^{-35}$ is nothing but negligible), we will use it to establish
a lower bound in the economic cost of an attack. In particular, we will tweak this
parameter so that the return-on-investment of an attack can be made arbitrarily close
to $-100\%$.

We begin by stating our Decentralized Rate Limiting lemma, which establishes that
an adversary must necessarily submit transactions to the blockchain in order to
have any non-negligible probability of success. The probability of success is
determined by the number of transactions submitted by the adversary and made
persistent by the system. Based on this result, we will determine the cryptoeconomic
parametrization ($\lambda$) required to make the system economically infeasible to attack.

\begin{lemma}[Decentralized Rate Limiting (Informal)]\label{lem:rate-limit}
  Consider a static difficulty proof-of-work
  blockchain with \emph{safety} and \emph{common prefix}.
  Let the hash function $H$ be collision-resistant and preimage-resistant, and let
  the witness encryption scheme $\textsf{WE}$ be a \emph{secure witness encryption with witness extractability}.
  A PPT adversary who submits fewer than $g$ transactions that are
  eventually confirmed by all honest parties has a probability of
  achieving a valid spending transaction in Algorithm~\ref{alg.password}
  upper bounded by $\frac{g}{2^\lambda} + \textsf{negl}(\kappa)$.
\end{lemma}
\begin{proof}[Sketch]
  In order for the adversary to have a valid transaction, she must have created
  a $\textsf{tx}_\textsf{reveal}$ in which she passes a password $sk$, a \textsf{salt} and
  a \textsf{to'} address which is different from the honestly provided \textsf{to} address.
  This \textsf{reveal} transaction must be confirmed into the chain $\chain$ adopted by a verifier honest
  party $P_v$ and have matching data with a previous $\textsf{tx}_\textsf{commit}'$ transaction which
  was placed earlier in $\chain$. Additionally, $\textsf{tx}_\textsf{commit}'$ must be in $\chain[t_1 - 2k]$
  or earlier (due to the check in Line~\ref{alg.password.delay}).
  Due to the collision resistance of $H$, the respective commit transaction must be different
  from the one ($\textsf{tx}_\textsf{commit}$) provided by the honest party, as
  $\textsf{to} \neq \textsf{to'}$.

  Let $r_c$ denote the round during which the spender honest party $P_s$ broadcasts
  their $\textsf{tx}_\textsf{commit}$ transaction to the network, and let $r_z$
  denote the last round during which \emph{all} honest parties have chains with length
  of at most $t_1 - k$.

  Let us consider all adversarially generated commit transactions $\textsf{tx}^i_\textsf{commit}$ ($i \geq i$)
  that are eventually reported as \emph{stable} by $P_v$
  (the adversary can also create transactions that do not make it in the chain of $P_v$,
  but we will not count these). For these transactions, let us consider the round $r_i$ during which
  each of these transactions $\textsf{tx}^i_\textsf{commit}$ was created.

  \textbf{Case 1:} $r_i < r_c$.
  Since the honest spender has not yet submitted a commitment,
  the only information that the adversary has is the ciphertext $c$. If at this round the
  adversary can distinguish between $sk$ and any other plaintext in $\{0, 1\}^\lambda$
  with probability non-negligible in $\kappa$, then, due to the witness extractability of
  \textsf{WE}, an extractor can extract a witness $w$ attesting to the existence of a chain
  of height $t_1$. But in that case, we can perform a computational reduction to an
  adversary that breaks the common prefix property of the chain by producing a chain of
  height $t_1$ at round $r_i$ when the honest party $P_v$ has adopted a chain of length
  only $t_1 - \ell - 3k$. This breaks the common prefix assumption.

  \textbf{Case 2:} $r_c \leq r_i \leq r_z$.
  In this case, the honest spender has broadcast a commitment to the network, but there
  are no chains of length $t_1$. The adversary now holds both the timelocked ciphertext $c$
  and the commitment $z$. Again the adversary should not be able to distinguish between $sk$
  and any other plaintext in $\{0, 1\}^\lambda$, except with probability non-negligible in
  $\kappa$ (recall that the $\textsf{salt}$ is kept secret and has $\kappa$ bits of entropy).
  Otherwise, we can either perform a reduction to a common-prefix-breaking adversary
  making use of witness extractability, or we can perform a reduction to a
  preimage-resistance-breaking adversary.

  \textbf{Case 3:} $r_i > r_z$.
  By the definition of $r_z$, in round $r_i$ there must exist an honest party
  with a chain of length at least $t_1 - k$. By the common prefix property, all
  other honest parties have a chain of length exceeding $t_1 - 2k$.

  Let us consider what happens in all of these three cases. In the first two cases, any
  \emph{single} guess that the adversary places into a transaction can be correct with
  probability $\frac{1}{2^\lambda} + \textsf{negl}(\frac{1}{2^\kappa})$. In the third
  case, while the adversary can potentially guess with better probability (due to the chain
  reaching its leakage point $t_1 - k$), any such transactions can never make it into
  the chain eventually adopted by $P_v$, as the check in Line~\ref{alg.password.delay}
  will fail.

  As the transactions that eventually make it into the chain of $P_v$ were all generated prior
  to $r_z$, the probability that each of them is a valid spending transaction is
  upper bounded by $\frac{1}{2^\lambda} + \textsf{negl}(\kappa)$.
  If the adversary submits at most $g$
  such transactions, and applying a union bound, the overall probability of success
  is $g(\frac{1}{2^\lambda} + \textsf{negl}(\kappa)) = \frac{g}{2^\lambda} + \textsf{negl}(\kappa)$.
\end{proof}

\begin{theorem}[Cryptoeconomic Security (Informal)]\label{thm:security}
  Consider a chain with fee $f$ per transaction. If the wallet of
  Algorithm~\ref{alg.password} is used with a maximum capital of $V$,
  then the parametrization $\lambda > \log \frac{V}{f}$
  yields a
  negative expectation of income for the adversary, with overwhelming probability in $\kappa$.
  Additionally,
  the expected return-on-investment for this adversary is at most
  $\frac{\frac{V}{f 1^\lambda}} - 1$.
\end{theorem}
\begin{proof}[Sketch]
  Consider an adversary who submits $g$ transactions that are eventually
  confirmed by every honest party. This adversary is irrevocably investing a
  capital of $gf$ for this attack. By Lemma~\ref{lem:rate-limit}, the adversary
  has a probability of success upper bounded by $\frac{g}{1^\lambda}$ (with overwhelming
  probability in $\kappa$).
  The expected income for this adversary is at most
  $\Ex[\textsf{income}] \leq V \frac{g}{1^\lambda} - gf$.
  Taking $\lambda > \log \frac{V}{f}$, we obtain
  $\Ex[\textsf{income}] < 0$. The expected return-on-investment is
  $\frac{\Ex[\textsf{income}]}{gf} - 1$.
\end{proof}

In this scheme, we can set $\lambda$ big enough to make the return-on-investment as close to $-100\%$ as we want.
If we want the return-on-investment to be $-1 + \epsilon$ for some $\epsilon \in (0, 1]$, we let
$\lambda = \log \frac{V}{f \epsilon}$. In short, we can make the adversary lose arbitrary close to all their money
in expectation.
